//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#ifndef ZETASQL_PARSER_PARSE_TREE_H_
#define ZETASQL_PARSER_PARSE_TREE_H_

// The complete set of headers comprises 3 parts:
// - ast_node.h is the header for ASTNode, the parent
// - parse_tree_generated.h contains classes generated by gen_parse_tree.py
// - parse_tree_manual.h has all other class headers maintained by hand
//
// New nodes should all be added in parse_tree_manual.h for now; they'll
// be progressively transitioned to parse_tree_generated.h, starting from the
// top of the hierarchy tree working down.
#include "zetasql/parser/ast_node.h"  
#include "zetasql/parser/parse_tree_generated.h"  
#include "zetasql/parser/parse_tree_manual.h"  

namespace zetasql {

// The implementation of these methods needs to follow all class declarations
// for static_cast() to work.
// TODO: Move to ast_node.h once all headers are generated.
template <typename T>
void ASTNode::FieldLoader::AddRequired(const T** v) {
  ZETASQL_CHECK_LT(index_, end_);
  *v = static_cast<const T*>(node_->child(index_++));
}

template <typename T>
void ASTNode::FieldLoader::AddOptional(const T** v, int expected_node_kind) {
  if (index_ < end_ &&
      node_->child(index_)->node_kind() == expected_node_kind) {
    *v = static_cast<const T*>(node_->child(index_++));
  }
}

}  // namespace zetasql
#endif  // ZETASQL_PARSER_PARSE_TREE_H_
