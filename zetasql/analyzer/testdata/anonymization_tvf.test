[default language_features=ANONYMIZATION,TABLE_VALUED_FUNCTIONS]
[default enable_ast_rewrites]
[no_expect_error_location]
select with anonymization anon_count(* CLAMPED BETWEEN 0 AND 100)
from tvf_no_args();
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(1) INT64, optional(1) INT64) -> INT64)
              +-Literal(type=INT64, value=0)
              +-Literal(type=INT64, value=100)

Rewrite ERROR: A SELECT WITH ANONYMIZATION query must query at least one table containing user data
==

# Allow expression TVF arguments that don't reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_templated_arg_with_anonymization_uid(
  (select cast(42 as bool) as bool_column))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-expr=
        |         +-SubqueryExpr
        |           +-type=BOOL
        |           +-subquery_type=SCALAR
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$expr_subquery.bool_column#1]
        |               +-expr_list=
        |               | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |               +-input_scan=
        |                 +-SingleRowScan
        +-aggregate_list=
          +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_templated_arg_with_anonymization_uid.column_int64#14]
        |   |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-expr=
        |   |   |     +-SubqueryExpr
        |   |   |       +-type=BOOL
        |   |   |       +-subquery_type=SCALAR
        |   |   |       +-subquery=
        |   |   |         +-ProjectScan
        |   |   |           +-column_list=[$expr_subquery.bool_column#1]
        |   |   |           +-expr_list=
        |   |   |           | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |           +-input_scan=
        |   |   |             +-SingleRowScan
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=tvf_one_templated_arg_with_anonymization_uid.column_int64#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | +-$k_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#20)
==

# Disallow expression TVF arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_templated_arg_with_anonymization_uid(
  (select cast(42 as bool) as bool_column from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-expr=
        |         +-SubqueryExpr
        |           +-type=BOOL
        |           +-subquery_type=SCALAR
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$expr_subquery.bool_column#13]
        |               +-expr_list=
        |               | +-bool_column#13 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |               +-input_scan=
        |                 +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#25 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypesWithAnonymizationUid in arguments of TVF tvf_one_templated_arg_with_anonymization_uid
==

# Disallow relation arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select * from SimpleTypes))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |       +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypes in arguments of TVF tvf_one_relation_arg_with_anonymization_uid
==

# Disallow relation arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(TABLE SimpleTypes)
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |       +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypes in arguments of TVF tvf_one_relation_arg_with_anonymization_uid
==

# Disallow relation arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select * from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, uid INT64, numeric NUMERIC>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |       +-argument_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypesWithAnonymizationUid in arguments of TVF tvf_one_relation_arg_with_fixed_output
==

# Disallow relation arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  TABLE SimpleTypesWithAnonymizationUid)
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, uid INT64, numeric NUMERIC>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |       +-argument_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypesWithAnonymizationUid in arguments of TVF tvf_one_relation_arg_with_fixed_output
==

# Disallow nested anonymization in TVF args
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select with anonymization anon_count(*) from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#16 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#16]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#16]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$aggregate.$agg1#13]
        |       |   +-input_scan=
        |       |     +-AnonymizedAggregateScan
        |       |       +-column_list=[$aggregate.$agg1#13]
        |       |       +-input_scan=
        |       |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       |       +-aggregate_list=
        |       |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
        |       +-argument_column_list=[$aggregate.$agg1#13]
        +-aggregate_list=
          +-$agg1#16 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Nested SELECT WITH ANONYMIZATION queries are not supported
==

# Disallow relation arguments that reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select * from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, uid INT64, numeric NUMERIC>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |       +-argument_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: A TVF inside a SELECT WITH ANONYMIZATION query may not reference a table in that TVF's arguments, but found table SimpleTypesWithAnonymizationUid in arguments of TVF tvf_one_relation_arg_with_fixed_output
==

# Allow tables containing user data to be referenced in TVFs that are not child
# nodes of anonymization scans.
select with anonymization anon_count(*)
from SimpleTypesWithAnonymizationUid
union all
select count(*) from tvf_one_relation_arg_with_fixed_output(
  (select cast(42 as bool) as bool_column from SimpleTypesWithAnonymizationUid))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#30 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#30]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-AnonymizedAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#29]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#29]
        |       +-input_scan=
        |       | +-TVFScan
        |       |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       |   +-argument_list=
        |       |     +-FunctionArgument
        |       |       +-scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=[$subquery1.bool_column#26]
        |       |       |   +-expr_list=
        |       |       |   | +-bool_column#26 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       |       +-argument_column_list=[$subquery1.bool_column#26]
        |       +-aggregate_list=
        |         +-$agg1#29 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-output_column_list=[$aggregate.$agg1#29]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_all.$col1#30 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#30]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-AnonymizedAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#31], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#34 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#31)
      | |       |   +-aggregate_list=
      | |       |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-$agg1#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
      | |       | +-$k_threshold_col#37 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=INT64, value=0)
      | |       |     +-Literal(type=INT64, value=1)
      | |       +-k_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#29]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#29]
        |       +-input_scan=
        |       | +-TVFScan
        |       |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       |   +-argument_list=
        |       |     +-FunctionArgument
        |       |       +-scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=[$subquery1.bool_column#26]
        |       |       |   +-expr_list=
        |       |       |   | +-bool_column#26 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       |       +-argument_column_list=[$subquery1.bool_column#26]
        |       +-aggregate_list=
        |         +-$agg1#29 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-output_column_list=[$aggregate.$agg1#29]

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#31], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
}
==

# Disallow nested anonymization in TVF args
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select with anonymization anon_count(*) from SimpleTypes))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#22 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#22]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#22]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$aggregate.$agg1#19]
        |       |   +-input_scan=
        |       |     +-AnonymizedAggregateScan
        |       |       +-column_list=[$aggregate.$agg1#19]
        |       |       +-input_scan=
        |       |       | +-TableScan(table=SimpleTypes)
        |       |       +-aggregate_list=
        |       |         +-$agg1#19 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
        |       +-argument_column_list=[$aggregate.$agg1#19]
        +-aggregate_list=
          +-$agg1#22 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Nested SELECT WITH ANONYMIZATION queries are not supported
==

# Valid TVF query that doesn't explicitly project the uid column
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        +-aggregate_list=
          +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#15, $group_by.$uid#16]
        |   +-input_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#13], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        |   +-group_by_list=
        |   | +-$uid#16 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#13)
        |   +-aggregate_list=
        |     +-$agg1_partial#15 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#15)
        | +-$k_threshold_col#19 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#19)
==

# Valid TVF query that doesn't explicitly project the uid column, but does
# project columns that occur positionally before and after it in the TVF result
# schema. This checks that the uid column is being inserted positionally.
select with anonymization
  column_int32, column_string, anon_count(*)
from tvf_no_args_with_anonymization_uid()
group by column_int32, column_string;
--
QueryStmt
+-output_column_list=
| +-$groupby.column_int32#13 AS column_int32 [INT32]
| +-$groupby.column_string#14 AS column_string [STRING]
| +-$aggregate.$agg1#12 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(column_list=tvf_no_args_with_anonymization_uid.[column_int32#6, column_string#8], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[5, 7])
        +-group_by_list=
        | +-column_int32#13 := ColumnRef(type=INT32, column=tvf_no_args_with_anonymization_uid.column_int32#6)
        | +-column_string#14 := ColumnRef(type=STRING, column=tvf_no_args_with_anonymization_uid.column_string#8)
        +-aggregate_list=
          +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.column_int32#13 AS column_int32 [INT32]
| +-$groupby.column_string#14 AS column_string [STRING]
| +-$aggregate.$agg1#12 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $groupby.column_int32_partial#18, $groupby.column_string_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-TVFScan(column_list=tvf_no_args_with_anonymization_uid.[column_int32#6, column_int64#15, column_string#8], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[5, 6, 7])
        |   +-group_by_list=
        |   | +-column_int32_partial#18 := ColumnRef(type=INT32, column=tvf_no_args_with_anonymization_uid.column_int32#6)
        |   | +-column_string_partial#19 := ColumnRef(type=STRING, column=tvf_no_args_with_anonymization_uid.column_string#8)
        |   | +-$uid#20 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-column_int32#13 := ColumnRef(type=INT32, column=$groupby.column_int32_partial#18)
        | +-column_string#14 := ColumnRef(type=STRING, column=$groupby.column_string_partial#19)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | +-$k_threshold_col#23 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#23)
==

# Valid TVF query explicitly projecting the uid column (which is named
# 'column_int64')
select with anonymization anon_sum(column_int64)
from tvf_no_args_with_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        +-aggregate_list=
          +-$agg1#12 :=
            +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
              +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#14, $group_by.$uid#15]
        |   +-input_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        |   +-group_by_list=
        |   | +-$uid#15 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   +-aggregate_list=
        |     +-$agg1_partial#14 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#14)
        | +-$k_threshold_col#18 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#18)
==

# Valid TVF containing user data joined with table containing user data
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
inner join SimpleTypesWithAnonymizationUid b on a.column_int64 = b.uid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#7, SimpleTypesWithAnonymizationUid.uid#22]
        |   +-left_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   +-right_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#22)
        +-aggregate_list=
          +-$agg1#24 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#26, $group_by.$uid#27]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#7, SimpleTypesWithAnonymizationUid.uid#22]
        |   |   +-left_scan=
        |   |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   |   +-right_scan=
        |   |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   |   +-join_expr=
        |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |       +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#22)
        |   +-group_by_list=
        |   | +-$uid#27 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   +-aggregate_list=
        |     +-$agg1_partial#26 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#24 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#26)
        | +-$k_threshold_col#30 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#30)

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
}
==

# TVF containing user data joined with table containing user data without
# explicit join on uid
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
cross join SimpleTypesWithAnonymizationUid b;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, alias="a")
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypesWithAnonymizationUid, alias="b")
        +-aggregate_list=
          +-$agg1#24 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Joins between tables containing private data must explicitly join on the user id column in each table, add 'ON a.column_int64=b.uid'
==

# Valid TVF containing user data joined with table containing non-user data
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
cross join SimpleTypes b;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, alias="a")
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes, alias="b")
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#31]
        |   |   +-left_scan=
        |   |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#31], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   |   +-right_scan=
        |   |     +-TableScan(table=SimpleTypes, alias="b")
        |   +-group_by_list=
        |   | +-$uid#34 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#31)
        |   +-aggregate_list=
        |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#30 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
        | +-$k_threshold_col#37 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
==

# Valid TVF containing non-user data joined with table containing user data
select with anonymization anon_count(*)
from tvf_no_args() a
cross join SimpleTypesWithAnonymizationUid b;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, alias="a")
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypesWithAnonymizationUid, alias="b")
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $group_by.$uid#19]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.uid#16]
        |   |   +-left_scan=
        |   |   | +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, alias="a")
        |   |   +-right_scan=
        |   |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   +-group_by_list=
        |   | +-$uid#19 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | +-$k_threshold_col#22 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#22)

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
}
==

# TODO: Nested user IDs are not currently supported.
select with anonymization anon_count(*)
from tvf_no_args_with_nested_anonymization_uid();
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_with_nested_anonymization_uid(() -> TABLE<user_info PROTO<zetasql_test.TestExtraPB>>), signature=() -> TABLE<user_info PROTO<zetasql_test.TestExtraPB>>)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Nested user IDs are not currently supported for TVFs (in TVF tvf_no_args_with_nested_anonymization_uid)
==

# TODO: Fetching user IDs from a value tables is not currently
# supported.
select with anonymization anon_count(*)
from tvf_no_args_value_table_with_nested_anonymization_uid();
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test.TestExtraPB>>)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Anonymization is not currently supported for TVFs that produce value tables (in TVF tvf_no_args_value_table_with_nested_anonymization_uid)
